# adaptive_sampling_scripts
Scripts for adaptive sampling analysis

### analyse_RU.py

`analyse_RU.py` is an edited version of the script available [here](https://github.com/SR-Martin/Adaptive-Sequencing-Analysis-Scripts).
This edited script allows removal of multimapping reads from [Minimap2](https://github.com/lh3/minimap2) and filtering based on % identity to the aligning reference.

To use analyse_RU.py, direct it to a read directory containing `fastq_pass` and `fastq_fail` folders containing `fastq.gz` files generated by a basecaller:
```
python analyse_RU.py -f /path/to/read/directory/ -p 0.84 -o /output/prefix -c 1-256 -i /path/to/reference.fasta -t "23F,19A,19F"
```

To specify which sequence(s) the `reference.fasta` to align to, use the `-t` flag using a comman separated list as above. The names must match fasta headers in the `reference.fasta` file.

To specify which channels to separate (e.g. if you have used adaptive sampling on some channels), use `-c`, followed by a hyphen separated pair of integers between 1 and 512.

To change the proportion of an ALIGNMENT (NOTE: not the full read) that must match a reference to be deemed as correct, use the `-p` flag. As default, a multimapping read will assigned to the sequence it has the greatest aligning proportion to (turn this off using `-r`).

By default, both pass and fail reads are used. To use pass only, specify `-b`

This will generate a `_summary.txt` file containing statistics about read mapping and yield, and `_bootstrap.txt`, which contains bootstrap enrichment calculations (change number of bootstrap samples with `-bs`)

### analyse_coverage.py

`analyse_coverage.py` determines the proportion of a reference covered by reads. 

Run with:
```
python analyse_coverage.py -f /path/to/read/directory/ -p 0.84 -o output/prefix -i /path/to/reference.fasta -t "23F,19A,19F"
```

`-p`, `-c`, `-b`, `-r` and `-t` behave the same as with `analyse_RU.py`.

This will output a `X_adaptive_hist.csv` (for channels specified by `-c`) and `X_control_hist.csv` (for all other channels) for each barcode, which details the coverage at each position in the reference. `X` specifies which reference was been aligned to. Additionally, a `_summary.txt` file detailing total bases aligning and the average coverage to each reference sequence is generated.

### analyse_read_lengths.py

`analyse_read_lengths.py` generates an output file summarising read lengths from a sequencing run. It can be used to analyse simulated runs from bulk recordings.

Run with:
```
python analyse_read_lengths.py --indir /path/to/read/directory/ --out /output/filename"
```

This generates a file detailing the read length of all reads along with their barcode, channel, and whether they passed quality filtering.

### analyse_unblocks.py

`analyse_unblocks.py` aligns reads to a given reference and parses their length. It can be used to analyse simulated runs from bulk recordings.

Run with:
```
python split_by_channel.py --indir /path/to/read/directory/ --out /output/filename --ref /path/to/reference.fasta --target "23F" --loci /path/to/locus.fasta --mux-period 480
```

To specify which sequence(s) the `reference.fasta` to align to, use the `--target` flag using a comman separated list as above. The names must match fasta headers in the `reference.fasta` file.

If you have loci of interest within the `reference.fasta`, you can separately supply it to `--loci` in fasta format. These will be aligned to the reference, and the coordinates used in read mapping to assign reads at correctly mapping to or missing the locus.

To ignore reads from the start of the run e.g. during the mux period, specify using `--mux-period` (in seconds).

### kmer_simulation.R

`kmer_simulation.R` is an R script set up to simulate error-prone reads from a target and non-target genome and determine the sensitity and specificity of pseudoalignment using different read lengths (`read.lengths` variable), mutation rates (`mu.rates` variable) and k-mer lengths (`kmer.sizes` variable). 

This script will automatically generate plots describing:
- pseudoalignment sensitivity (`kmer_mu_comp_readlen` plot)
- pseudoalignment specificity (`kmer_random_match_readlen` plot)
- effect of identity cut-off (`kmer_cutoff_mu` plot)
- Reciever operator curve (`ROC_len` plot)
- Concordance between estimated and real read identity (`mash_mu_concordance` plot)
- RMSE between estimate and real read identity (`RMSE_mash` plot)

To avoid rerunning simulations, k-mer sequences are placed in `all_simulations.csv` and `all_cutoffs.csv` for re-generating plots.

### loci_cutter.py

`loci_cutter.py` aligns a database containing loci of interest to individual genomes and 'cuts' it out, generating `fasta` files containing the locus and the remainder of the genome.

Run with:
```
python loci_cutter --infile /path/to/infile.txt --query /path/to/locus.fasta --cutoff 0.7 --outpref /output/prefix --separate --count
```

`--infile` is a list of file paths to `fasta` files containing sequences from which to cut loci from (one path per line). 

`--query` is a `fasta` file containing the loci to align and cut.

`--cutoff` defines the minimum identity between the input sequence and an aligned locus to cut.

`--separate` places the cut loci and remaining sequence in different files, otherwise placed in the same file.

`--count` generates an output file detailing the number of each loci in `--query` found in the `fasta` within `--infile`.


This will generate `_cut.fa` which contains the locus, and `_rem.fa` which is the remainder of the sequence. If no locus is found, the sequence will be generated as `_nocut.fas` 

### split_by_channel.py

`split_by_channel.py` can be used to split reads into two separated files depending on specified channel. For use when adaptive sampling has been used on some but not all channels.

Run with:
```
python split_by_channel.py --infile /path/to/reads.fastq --out /output/prefix --channels 1-256
```

This will output `target.fastq` for reads from the stipulated channels, and `nontarget.fastq` for all others.